Sorting Algorithms in C++

A comprehensive collection of sorting algorithms implemented in C++. This repository serves as an educational resource for understanding various sorting techniques, their implementations, and performance characteristics.

 Table of Contents

路 Algorithms Overview
路 Complexity Analysis
路 Lyman's Analogy
路 Installation & Usage
路 Examples
路 Contributing
路 License

Algorithms Overview

1. Bubble Sort

A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.

Key Characteristics:

路 Stable sorting algorithm
路 In-place sorting
路 Adaptive (performs better on partially sorted data)

2. Selection Sort

Divides the input list into two parts: a sorted sublist and an unsorted sublist. The algorithm repeatedly finds the minimum element from the unsorted part and puts it at the beginning.

Key Characteristics:

路 Not stable (may change the relative order of equal elements)
路 In-place sorting
路 Performs a limited number of swaps

3. Insertion Sort

Builds the final sorted array one item at a time by repeatedly taking the next element and inserting it into the correct position in the already-sorted part.

Key Characteristics:

路 Stable sorting algorithm
路 In-place sorting
路 Efficient for small data sets or nearly sorted data

4. Merge Sort

A divide-and-conquer algorithm that divides the input array into two halves, sorts them recursively, and then merges the two sorted halves.

Key Characteristics:

路 Stable sorting algorithm
路 Not in-place (requires additional memory)
路 Consistent O(n log n) performance

5. Quick Sort

Another divide-and-conquer algorithm that selects a 'pivot' element and partitions the array around the pivot, then recursively sorts the sub-arrays.

Key Characteristics:

路 Not stable
路 In-place sorting (with efficient implementations)
路 Generally the fastest sorting algorithm in practice

6. Heap Sort

Creates a heap data structure from the input array and then repeatedly extracts the maximum element to form the sorted array.

Key Characteristics:

路 Not stable
路 In-place sorting
路 Guaranteed O(n log n) performance

Complexity Analysis

Algorithm Time Complexity (Best) Time Complexity (Average) Time Complexity (Worst) Space Complexity
Bubble Sort O(n) O(n虏) O(n虏) O(1)
Selection Sort O(n虏) O(n虏) O(n虏) O(1)
Insertion Sort O(n) O(n虏) O(n虏) O(1)
Merge Sort O(n log n) O(n log n) O(n log n) O(n)
Quick Sort O(n log n) O(n log n) O(n虏) O(log n)
Heap Sort O(n log n) O(n log n) O(n log n) O(1)

Lyman's Analogy

To better understand sorting algorithms, consider this classroom analogy:

路 Bubble Sort: Like students lining up by height. The tallest keeps bubbling to the end through successive comparisons with neighbors.
路 Selection Sort: Like a teacher selecting the shortest student to stand first, then the next shortest, and so on.
路 Insertion Sort: Like sorting a hand of playing cards - you take one card at a time and insert it in its proper position.
路 Merge Sort: Like dividing the class into pairs, sorting each pair, then merging sorted pairs into groups of four, and so on.
路 Quick Sort: Like choosing a pivot student (perhaps of median height), having shorter students stand on one side and taller on the other, then repeating the process for each side.
路 Heap Sort: Like building a pyramid (heap) of students by height, then repeatedly taking the tallest from the top and rebuilding the pyramid.

Installation & Usage

Prerequisites

路 C++ compiler (GCC, Clang, or MSVC)
路 CMake (optional, for building with CMake)

Compilation

```bash
# Using g++ directly
g++ -std=c++11 -o sort_demo main.cpp

# Using CMake
mkdir build
cd build
cmake ..
make
```

Running the Program

```bash
./sort_demo
```
Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

1. Fork the project
2. Create your feature branch (git checkout -b feature/AmazingFeature)
3. Commit your changes (git commit -m 'Add some AmazingFeature')
4. Push to the branch (git push origin feature/AmazingFeature)
5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

 Resources

路 GeeksforGeeks Sorting Algorithms
路 Visualgo Sorting Visualization
路 Khan Academy Algorithms Course

---
Happy Sorting......

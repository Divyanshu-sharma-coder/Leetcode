Approaches Based on the Code
The provided C++ code demonstrates two efficient ways to sort an array containing only the values 0, 1, and 2 (often representing colors like red, white, and blue in sorting problems). This is a classic problem known as "Sort Colors" or the "Dutch National Flag Problem." Both approaches aim to sort the array in-place (modifying the original array) with O(n) time complexity, but they differ in their mechanics. I'll break them down step by step, based directly on the code.
1. Optimized Counting Approach
This method uses a simple counting technique to tally the occurrences of each value (0, 1, and 2) and then reconstructs the array in sorted order. It's straightforward and works well when the range of values is small (here, just three possible values).
Step-by-Step Breakdown:
Initialize three counters: count0 for 0s, count1 for 1s, and count2 for 2s.
Iterate through the array once (from index 0 to n-1) and increment the appropriate counter for each element.
Reset an index pointer (idx) to 0.
Overwrite the array by placing all 0s first (using a loop that runs count0 times), followed by all 1s (count1 times), and then all 2s (count2 times).
This results in a sorted array without needing comparisons or swaps during the reconstruction.
Time Complexity: O(n) – Two passes over the array (one for counting, one for overwriting).
Space Complexity: O(1) – Only a few extra variables for counters.
Advantages: Simple to implement; no swaps needed.
Disadvantages: Requires two passes; not truly in-place if you consider the counters, but it's efficient for small ranges.
2. Dutch National Flag Algorithm (Three-Pointer Approach)
This is a one-pass algorithm that uses three pointers (low, mid, and high) to partition the array into sections for 0s, 1s, and 2s. It's more efficient in terms of passes and is inspired by quicksort's partitioning.
Step-by-Step Breakdown:
Initialize pointers: low and mid at the start (index 0), and high at the end (index k-1, where k is the array size).
While mid <= high:
If the element at mid is 0: Swap it with the element at low, then increment both low and mid. This moves 0s to the left section.
If the element at mid is 1: Just increment mid (1s stay in the middle section).
If the element at mid is 2: Swap it with the element at high, then decrement high. This moves 2s to the right section. (Note: mid is not incremented here because the swapped element from high needs to be checked.)
The loop continues until mid surpasses high, at which point the array is sorted: 0s from index 0 to low-1, 1s from low to high, and 2s from high+1 to the end.
Time Complexity: O(n) – Single pass with constant-time operations.
Space Complexity: O(1) – Only pointers are used.
Advantages: One pass; more efficient for large arrays; handles sorting in-place with minimal operations.
Disadvantages: Slightly more complex logic due to swaps and pointer management; potential for more swaps than the counting method.
Both approaches assume the array contains only 0, 1, and 2. If invalid values are present, additional checks would be needed.
Examples
Let's use the array from the code: {2, 0, 2, 1, 1, 0, 1, 2, 0, 0} (size 10).
Example for Optimized Counting Approach:
Count: 0 appears 4 times, 1 appears 3 times, 2 appears 3 times.
Reconstruct: Place four 0s, then three 1s, then three 2s.
Sorted Array: {0, 0, 0, 0, 1, 1, 1, 2, 2, 2}
Another example array: {1, 0, 2, 1, 0} (size 5).
Count: 0:2, 1:2, 2:1.
Sorted: {0, 0, 1, 1, 2}
Edge case: All same values, e.g., {2, 2, 2} – Sorted remains {2, 2, 2}. Empty array: Nothing to sort.
Example for Dutch National Flag Algorithm:
Using the same array {2, 0, 2, 1, 1, 0, 1, 2, 0, 0}:
Start: low=0, mid=0, high=9.
mid=0 (value=2): Swap with high=9 (0), array becomes {0, 0, 2, 1, 1, 0, 1, 2, 0, 2}, high=8.
mid=0 (now 0): Swap with low=0 (itself), low=1, mid=1.
mid=1 (0): Swap with low=1 (itself), low=2, mid=2.
mid=2 (2): Swap with high=8 (0), array {0, 0, 0, 1, 1, 0, 1, 2, 2, 2}, high=7.
And so on... (continues until sorted as {0, 0, 0, 0, 1, 1, 1, 2, 2, 2}).
Another example: {1, 0, 2, 1, 0}.
After processing: {0, 0, 1, 1, 2}.
Edge case: {0, 1, 2} – Already sorted after minimal operations. All 1s: Pointers move without swaps.
Layman's Analogy
Imagine you're organizing a bunch of colored marbles: red (0), white (1), and blue (2) – like sorting the stripes on the Dutch national flag (which is why the second algorithm is named after it).
Counting Approach: You first go through all the marbles and count how many of each color you have (e.g., 4 red, 3 white, 3 blue). Then, you line them up in a row: dump all the reds first, then whites, then blues. It's like taking inventory at a store before restocking shelves in order – simple but requires two steps (counting and placing).
Dutch National Flag Approach: Picture three sections in a line: left for reds, middle for whites, right for blues. You start with a "checker" (mid pointer) going through the marbles one by one. If it's red, toss it to the front (swap with low) and move the front boundary forward. If it's white, leave it in the middle and keep checking. If it's blue, fling it to the back (swap with high) and shrink the back boundary. By the end, everything's neatly divided without recounting – like herding cats into pens with a single sweep through the room.

ğŸ§© Question: Maximum Subarray (LeetCode #53)

Problem Statement:
Given an integer array nums, find the contiguous subarray (containing at least one number) that has the largest sum, and return its sum.


---

Example 1:

Input:
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]

Output:
6

Explanation:
The subarray [4, -1, 2, 1] has the largest sum = 6.


---

Example 2:

Input:
nums = [1]
Output:
1


---

Example 3:

Input:
nums = [5, 4, -1, 7, 8]
Output:
23
Explanation:
The entire array is the maximum subarray.


---

âš™ï¸ Approach (Kadaneâ€™s Algorithm)

Your approach is Kadaneâ€™s Algorithm, which runs in O(n) time and O(1) space â€” the most optimal solution.


---

ğŸ§  Step-by-Step Explanation:

1. Initialize two variables:

current_sum = 0 â†’ tracks the running subarray sum.

max_sum = array[0] â†’ stores the maximum sum found so far.



2. Iterate through the array:

Add each element to current_sum.

Update max_sum if current_sum becomes greater than max_sum.

If current_sum drops below 0, reset it to 0 (because a negative sum will only reduce the total of future subarrays).



3. Return max_sum after the loop.



âš¡ Dry Run Example

Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]

i	array[i]	current_sum	max_sum	Comment

0	-2	-2	-2	current_sum < 0 â†’ reset to 0
1	1	1	1	max_sum updated
2	-3	-2	1	reset to 0
3	4	4	4	updated
4	-1	3	4	continue
5	2	5	5	updated
6	1	6	6	updated
7	-5	1	6	continue
8	4	5	6	continue


âœ… Result: max_sum = 6


---

ğŸ’¡ Lymanâ€™s Analogy (Intuitive Understanding)

Imagine youâ€™re walking on a path of coins and debts (positive = coins, negative = debts).

You start walking, collecting coins and paying debts as you go.

If your total balance becomes negative, you drop everything and start fresh â€” because carrying a loss wonâ€™t help you collect more coins later.

You always keep track of the maximum coins you ever held during the journey.


That maximum balance = max_sum ğŸ’°


---

ğŸ Final Thoughts

âœ… Algorithm Used: Kadaneâ€™s Algorithm
âœ… Time Complexity: O(n)
âœ… Space Complexity: O(1)
âœ… Concepts Used: Dynamic Programming (optimized)


---
